from collections.abc import Mapping as ABC_Mapping
from typing import Any, Dict, Iterable, Iterator, List, Optional, Union, Sequence

class Array(): ...

class ArrowException(Exception): ...
class ArrowKeyError(ArrowException): ...

class Buffer:
    def to_pybytes(self) -> bytes: ...
    address: int
    is_cpu: bool
    is_mutable: bool
    parent: Buffer
    size: int

class ChunkedArray(Array): ...

class DataType: ...
class Field: ...
class Mapping: ...
class MemoryPool: ...
class Metadata(): ...

class Schema:
    def with_metadata(self, metadata: Dict[bytes, bytes]) -> Schema: ...
    metadata: Dict[bytes, bytes]
    names: List[str]

class RecordBatch:
    @classmethod
    def from_pydict(cls, mapping: Union[Dict[Any, Any], Mapping],
                    schema: Optional[Schema] = None,
                    metadata: Optional[Union[Dict[Any, Any], Mapping]] = None) \
            -> RecordBatch: ...
    def __len__(self) -> int: ...
    def replace_schema_metadata(self,
                                metadata: Optional[Dict[Any, Any]] = None) \
            -> RecordBatch: ...
    def to_pydict(self) -> Dict[Any, Any]: ...

    nbytes: int
    num_columns: int
    num_rows: int
    schema: Schema

class Table:
    @classmethod
    def from_pydict(cls, mapping: Dict[Any, Any],
                    schema: Optional[Schema] = None,
                    metadata: Optional[Union[Dict[Any, Any],
                                             Mapping]] = None) -> Table: ...
    @classmethod
    def from_batches(cls, batches: Union[Sequence[RecordBatch],
                                         Iterator[RecordBatch]],
                     schema: Optional[Schema] = None) -> Table: ...
    def __len__(self) -> int: ...
    def append_column(self, field: Union[str, Field],
                      column: Union[Array, List[Array], List[Any]]) -> Table: ...
    def replace_schema_metadata(self,
                                metadata: Optional[Dict[Any, Any]] = None) \
            -> Table: ...
    def slice(self, offset: Optional[int] = 0,
              length: Optional[int] = None) -> Table: ...
    def to_batches(self, max_chunksize: Optional[int] = None,
                   kwargs: Optional[Dict[Any, Any]] = None) \
            -> List[RecordBatch]: ...
    def to_pydict(self) -> Dict[Any, Any]: ...

    nbytes: int
    num_columns: int
    num_rows: int
    schema: Schema

